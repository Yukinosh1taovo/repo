[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)



### DFS递归 记忆化搜索

```cpp
// 时间复杂度O(n) 空间复杂度O(n)
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, -1); // -1 表示该状态没有被计算过
//dfs(i) 表示从nums[0] 到nums[i]最多能偷多少
        function<int(int)> dfs = [&](int i) -> int {
            if (i < 0) return 0; // 递归边界(没有房子)
            if (memo[i] != -1) return memo[i]; // 之前计算过
            return memo[i] = max(dfs(i - 1), dfs(i - 2) + nums[i]);

        };
        return dfs(n - 1); // 从最后一个房子思考
    }
};
```

---

### 递推

```cpp
// 时间复杂度O(n) 空间复杂度O(n)
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 2, 0);  // 记录状态数组

        for (int i = 0; i < n; i++)
        {
            f[i + 2] = max(f[i + 1], f[i] + nums[i]); // 选与不选的情况取大
        }
        return f[n + 1];
    }
};
```

---

### 递推空间优化

```cpp
// 时间复杂度O(n) 空间复杂度O(1)
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        int f0 = 0, f1 = 0; // f1记录上一个状态 f0 记录上上个状态

        for (int i = 0; i < n; i++)
        {
            int new_f = max(f1, f0 + nums[i]);
            f0 = f1;
            f1 = new_f;
        }
        return f1;
    }
};
```



