[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)



### unordered_map做法

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 时间复杂度O(n)
        // 空间复杂度O(128)-> O(1)  因为s只出现字母数字符号空格 ascii码128
        int n = s.size();
        unordered_map<char, int> mp;  // 不能用unordered_map<string, int>
        int ans = 0;
        int l = 0, r = l;
        while (r < n) // 枚举右端点
        {
            mp[s[r]]++; // 创建mp[s[r]]的键赋初值0再++

            while (mp[s[r]] > 1) // 重复字符只会在最右端出现 while保证结束后无重复字符
            {
                mp[s[l]]--; // mp[s[l++]]--;
                l++;
            }
            ans = max(r - l + 1, ans); // 更新答案
            r++;
        }
        return ans;
    }
};
```

### unordered_set做法

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 时间复杂度O(n)
        // 空间复杂度O(128)-> O(1)  因为s只出现字母数字符号空格 ascii码128
        int n = s.size();
        unordered_set<char> window;  // 不能用unordered_map<string, int>
        int ans = 0;
        int l = 0, r = l;
        while (r < n) // 枚举右端点
        {
            char ch = s[r];  // mp[ch]++  没有先插入到哈希

            while (window.count(ch)) // 判断ch是否存在于集合 重复字符只会在最右端出现 while保证结束后无重复字符
            {
                window.erase(s[l]); // window.erase(s[l++]);
                l++;
            }
            window.insert(ch);
            ans = max(r - l + 1, ans); // 更新答案
            r++;
        }
        return ans;
    }
};
```

